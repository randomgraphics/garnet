# Tasks: Usable GenericDraw action + sample drawing a solid-color triangle

Goal: (1) Complete the GenericDraw Vulkan backend so it can execute a draw (pipeline bind + draw call). (2) Add a sample app (based on simple-triangle.cpp) that uses GenericDraw to draw a solid-color triangle on screen. No coding until the plan is reviewed.

--- PROGRESS (resume from "Last completed" / "In progress") ---
Last completed: Task 4.3
In progress: (none)
--- END PROGRESS ---

Reference:
- GenericDraw action: src/inc/garnet/rdg/actions.h (GenericDraw, GenericDraw::A, CreateParameters with vs/ps, renderTarget, mesh, drawParams).
- Vulkan implementation: src/core/rdg/vk-draw-actions.cpp (GenericDrawVulkan after Task 1.1; currently has TODO "do more graphics commands here").
- Sample to adapt: src/sample/rdg/simple-triangle.cpp (render loop with PrepareBackbuffer, Clear, ClearDepthStencil, Present; some APIs may be outdated).
- ClearRenderTarget::A in actions.h uses clearValues (struct: colors[8], depth, stencil) and renderTarget (RenderTarget with colors + depthStencil). CreateParameters use .gpu.
- RenderTarget: colors (StackArray<ColorTarget,8>), depthStencil (DepthStencil); ColorTarget = variant<Texture, Backbuffer> + subresourceIndex.
- GenericDraw::create() is declared in actions.h but not implemented in draw-actions.cpp (only ClearRenderTarget::create is).

Build/CI (run from repo root):
- Build: source env/garnet.rc && build.py d  (see .cursor/skills/use-build-py/SKILL.md).
- Lint+test: env/bin/cit.py  (see .cursor/skills/run-cit/SKILL.md).
- Run sample: from build dir (e.g. build/linux.gcc.d), ./bin/GNsample-rdg-simple-triangle. Requires a display (Wayland/X11); headless runs may crash in Backbuffer/window init.

Workflow / Conventions:
- Keep the repo buildable at the end of each task. If needed, introduce dummy or stub implementations (e.g. empty class, return nullptr, or no-op) so that the project still compiles and links.
- After completing each task, commit the change with a meaningful check-in message that describes what was done.
- Prefer passing the build after every task. If it is genuinely hard or would require a large, tangled change to keep the build green, you may relax this and note in the commit or PROGRESS why the build is temporarily broken; prefer small, buildable steps where practical.
- If blocked (e.g. missing API, unclear design, or build cannot be fixed in a reasonable way), stop and ask for human help rather than guessing.
- If a task is too complex or difficult, or the code change to finish the task or fix the build is not converging: pause, consider rolling back and trying a different approach (e.g. smaller step, different design), or simply stop and ask for human help.
- Before starting a new step: pull from GitHub to incorporate others' changes. If there are merge conflicts, add a pre-step to the current task to fix merge conflicts; resolve, verify build, commit, then continue.
- When starting a task: mark the task as in progress in PROGRESS, then commit the task file (e.g. "chore(agent): start Task X.Y") so everyone sees that work has begun.
- After starting a task and after completing it: push the repo to GitHub so progress is not lost if the local machine is unavailable.
- Run the sample once the initial version of the sample app exists, and after each step that touches the sample or GenericDraw: the run must complete without crash and without any Vulkan error. If there is a crash or Vulkan error, fix it before continuing to the next task.

---
PRE: Branch first, then fix build and commit
---

[ ] Task 0.0 — Create wip branch for this work
    - Create a new branch from current HEAD, e.g. wip/generic-draw-solid-triangle (or wip/generic-draw-triangle). Use a name that reflects the goal (GenericDraw + solid triangle sample).
    - Check out the new branch so all following work happens on it.
    - Verification: git branch shows the new wip/... branch; you are on that branch. Optionally commit the task list to the new branch (e.g. "chore(rdg): add task list for GenericDraw + solid-triangle sample").

[ ] Task 0.2 — Fix current build by commenting out incomplete code, then commit to the new branch
    - simple-triangle.cpp: Uses outdated or missing APIs (Workflow::Task requires name; ClearRenderTarget::A uses clearValues/renderTarget not .color; ClearDepthStencil does not exist; Submission::Result uses .executionResult). Comment out: ClearDepthStencil create; entire workflow task-building block (#if 0); fix result.result -> result.executionResult; use .gpu for ClearRenderTarget/PrepareBackbuffer/PresentBackbuffer; schedule("Render"). Comment out Texture::load, Mesh::load, Sampler::create to fix undefined link symbols until those are implemented.
    - exception.cpp: Remove or comment the #error "wtf" under #if !GN_ANDROID so non-Android builds compile.
    - Goal: build passes (build.py d). Sample may run with empty workflow; full task setup is re-enabled in Phase 5.
    - After task: commit your changes to the new branch with message e.g. "fix: comment out incomplete code to restore build (simple-triangle, exception)".

---
PHASE 1: Naming consistency
---

[ ] Task 1.1 — Rename GenericDrawActionVulkan to GenericDrawVulkan
    - In src/core/rdg/vk-draw-actions.cpp: rename class GenericDrawActionVulkan to GenericDrawVulkan everywhere (class name, constructor name, all log messages that mention the class, and the factory return type new GenericDrawActionVulkan(...) -> new GenericDrawVulkan(...)).
    - Naming matches the pattern: ClearRenderTarget -> ClearRenderTargetVulkan; GenericDraw -> GenericDrawVulkan (not GenericDrawActionVulkan).
    - Verification: Build succeeds. Grep for "GenericDrawActionVulkan" in the repo finds no matches.
    - After task: commit with message e.g. "refactor(rdg): rename GenericDrawActionVulkan to GenericDrawVulkan".

---
PHASE 2: GenericDraw factory and backend wiring
---

[ ] Task 2.1 — Implement GenericDraw::create() in draw-actions.cpp
    - Add GenericDraw::create(ArtifactDatabase & db, const StrA & name, const CreateParameters & params) in the same file and style as ClearRenderTarget::create.
    - Use params.context (not params.gpu; GenericDraw::CreateParameters has .context). Cast to GpuContextCommon and switch on api(); for Vulkan call createVulkanGenericDrawAction(db, name, params).
    - Return {} for null context, unsupported API, or backend failure.
    - Verification: Build succeeds. A unit test or the sample can call GenericDraw::create(...) and receive a non-null AutoRef<GenericDraw> when context is Vulkan.
    - After task: commit with message e.g. "feat(rdg): implement GenericDraw::create() and dispatch to Vulkan backend".

[ ] Task 2.2 — (Optional) Ensure CreateParameters naming is consistent
    - ClearRenderTarget::CreateParameters uses .gpu; GenericDraw::CreateParameters uses .context. No change required if call sites (e.g. sample) already pass .context for GenericDraw. If any code expects .gpu for GenericDraw, update that call site only.
    - Verification: Grep confirms GenericDraw::create call sites use .context.

---
PHASE 3: GenericDrawVulkan — pipeline and draw execution
---

[ ] Task 3.1 — Add dummy pipeline/draw path so build passes
    - Add a minimal, buildable path in GenericDrawVulkan: e.g. store an optional pipeline handle (or null); do not create a real VkPipeline yet. In execute(), if pipeline is null, skip bind and draw and return PASSED so the render graph does not fail. Optionally store CreateParameters (vs/ps) on the instance for later use; no pipeline creation in this task.
    - Ensure all new code paths compile and link (no undefined symbols). The goal is to keep the repo buildable after this task without requiring shaders or real pipeline implementation yet.
    - Verification: Build succeeds. GenericDrawVulkan::execute() can be called (e.g. from a future sample task) without crash; when pipeline is null, it returns PASSED and does not bind or draw.
    - After task: commit with message e.g. "feat(rdg): add dummy pipeline path in GenericDrawVulkan for buildable step".

[ ] Task 3.2 — Add real Vulkan pipeline creation and caching for GenericDrawVulkan
    - GenericDrawVulkan is constructed with CreateParameters that may include vs and ps (ShaderStageDesc: shaderBinary Blob, entryPoint StrA). When both vs and ps are present, create a VkPipeline (graphics) using the device from mGpu->device(). Pipeline must be compatible with dynamic rendering (no VkRenderPass). Create pipeline layout (no descriptors for the minimal solid-color triangle).
    - Cache the pipeline (and pipeline layout) on the GenericDrawVulkan instance so we do not recreate every frame. Pipeline creation can happen in execute() on first use, or in a lazy init.
    - If vs or ps is missing, leave pipeline null and log; execute() continues to use the dummy path (return PASSED, no draw).
    - Verification: Build succeeds. With vs+ps provided, a pipeline and layout are created and stored; no leak (destroy in destructor).
    - After task: commit with message e.g. "feat(rdg): add pipeline creation and cache for GenericDrawVulkan".

[ ] Task 3.3 — Implement bind pipeline and draw in GenericDrawVulkan::execute()
    - After acquiring the render pass (and before endRendering), if we have a valid pipeline: bind the graphics pipeline (vkCmdBindPipeline), then issue a draw call using GenericDraw::A drawParams (vertexCount, instanceCount, firstVertex, firstInstance). For the minimal path (no mesh): vkCmdDraw with vertexCount=3, instanceCount=1, firstVertex=0, firstInstance=0.
    - Verification: Execute path runs without crash when drawParams.vertexCount=3 and pipeline is bound; no Vulkan validation errors for the draw.
    - After task: commit with message e.g. "feat(rdg): bind pipeline and issue draw in GenericDrawVulkan::execute()".

[ ] Task 3.4 — (Optional) Viewport and scissor for dynamic rendering
    - Ensure the dynamic rendering region matches the render target extent. If the render pass manager or beginRendering already sets the render area, no change. Otherwise set viewport and scissor in the command buffer before the draw (using extent from the render target used in this task).
    - Verification: Triangle is not clipped incorrectly; no validation errors.

---
PHASE 4: Shader assets for solid-color triangle (rdg/sample, SPIR-V headers)
---

Goal: Shaders live under src/sample/rdg/; a script compiles them to SPIR-V and emits header files. The sample includes these headers directly. This avoids: (1) linking to a shader compiler at runtime, (2) loading shader files at runtime. The sample is self-contained (aside from shared library dependencies) and can be run from any working directory.

[ ] Task 4.1 — Add shader source files under src/sample/rdg/
    - Add vertex shader source: e.g. solid_triangle.vert (GLSL) that outputs clip-space positions for a full-screen triangle (e.g. three vertices via gl_VertexIndex: (-1,-1), (3,-1), (-1,3) in NDC). Entry point "main".
    - Add fragment shader source: e.g. solid_triangle.frag (GLSL) that outputs a solid color (e.g. vec4(1,0,0,1)). Entry point "main".
    - Verification: Files exist under src/sample/rdg/ (e.g. solid_triangle.vert, solid_triangle.frag). Build may not use them yet until the compile script and headers exist.
    - After task: commit with message e.g. "feat(sample): add GLSL sources for solid-triangle (vert + frag) under rdg/sample".

[ ] Task 4.2 — Create script to compile GLSL to SPIR-V and emit header files
    - Add a script (e.g. src/sample/rdg/compile_shaders.py or compile_shaders.sh) that: (1) takes the .vert and .frag sources, (2) compiles them to SPIR-V (e.g. using glslangValidator or glslc from Vulkan SDK / shaderc), (3) writes one or more C/C++ header files that define the SPIR-V as a const uint32_t[] (or unsigned int[]) with a named symbol and size/length, so the sample can #include them.
    - Output headers: e.g. solid_triangle_vert.spv.h and solid_triangle_frag.spv.h, or a single solid_triangle_spv.h with both arrays. Symbol names e.g. kSolidTriangleVertSpv / kSolidTriangleFragSpv and corresponding size constants.
    - Script should be runnable from the project (e.g. from repo root or from src/sample/rdg/). Document or use a standard tool (glslangValidator or glslc) so CI or developers can run it without extra runtime deps in the built binary.
    - Verification: Running the script produces the header file(s); headers contain valid array definitions that can be #included from C++.
    - After task: commit with message e.g. "feat(sample): add script to compile GLSL to SPIR-V headers for rdg/sample".

[ ] Task 4.3 — Wire script into build and use headers in sample
    - Integrate the compile script into the sample build (e.g. CMake custom command or target that runs the script and generates headers before compiling simple-triangle.cpp). Generated headers should live in build dir or a generated include path so the sample compiles with #include "solid_triangle_vert.spv.h" (or similar). Alternatively: commit generated headers so the sample has no build-time script dependency; then the script is optional for re-generating after shader edits.
    - In the sample (or in a later Phase 5 task): #include the SPIR-V header(s) and pass the byte/word arrays to GenericDraw::CreateParameters as shader binaries (e.g. Blob wrapping the array and size). No runtime file load; no shader compiler linked into the executable.
    - Verification: Build succeeds; sample binary does not depend on shader compiler runtime; sample runs regardless of current working directory (no relative paths to .spv files).
    - After task: commit with message e.g. "feat(sample): build SPIR-V headers and use them in simple-triangle (self-contained)".

---
PHASE 5: Sample app — simple-triangle using GenericDraw
---

[ ] Task 5.1 — Align simple-triangle.cpp with current RDG APIs
    - Current simple-triangle uses: ClearRenderTarget::A with color and renderTarget (old shape); ClearDepthStencil (not present in actions.h). Update to: ClearRenderTarget::A with clearValues (ClearValues struct: set colors[0].f4 to clear color, depth, stencil as needed) and renderTarget (RenderTarget: colors with one ColorTarget from backbuffer, depthStencil optional). Use CreateParameters with .gpu for ClearRenderTarget if that is the current convention.
    - Remove or replace ClearDepthStencil: either remove the clear-depth task and the clearDepthAction creation, or add a separate task later to introduce ClearDepthStencil if needed. For a single solid-color triangle, clearing only the backbuffer color is sufficient.
    - Verification: Build succeeds. Run sample: window opens; clear color appears (no triangle yet). No reference to undefined ClearDepthStencil.
    - After task: commit with message e.g. "fix(sample): align simple-triangle with current ClearRenderTarget::A and remove ClearDepthStencil".

[ ] Task 5.2 — Create GenericDraw action and add it to the workflow
    - Call genericDrawAction = GenericDraw::create(*db, "draw_triangle", GenericDraw::CreateParameters { .context = gpuContext, .vs = { .shaderBinary = ..., .entryPoint = "main" }, .ps = { .shaderBinary = ..., .entryPoint = "main" } }) with shader binaries from the SPIR-V headers produced in Phase 4 (include the generated headers and wrap the uint32_t arrays in a Blob for shaderBinary).
    - Add a workflow task: action = genericDrawAction, arguments = GenericDraw::A with renderTarget set to the same backbuffer (RenderTarget with one color target = backbuffer), drawParams set to { vertexCount=3, instanceCount=1, firstVertex=0, firstInstance=0 }, mesh left unset (or set to a minimal mesh if backend requires it).
    - Insert this task after the clear task and before the present task.
    - Verification: Build succeeds. Run sample: a solid-color triangle is visible on screen (color distinct from clear color).
    - After task: commit with message e.g. "feat(sample): wire GenericDraw into simple-triangle to draw solid triangle".

[ ] Task 5.3 — Final verification and cleanup
    - Run the sample from the build directory; confirm window shows a clear background and a solid-color triangle. No Vulkan validation errors (if validation layers are on). Close window and confirm clean exit.
    - Final visual verification: use a backbuffer readback action (or equivalent) to capture what was rendered; take a screenshot (or save the readback image). Inspect the content to ensure it matches the goal: a solid-color triangle (e.g. red) in the middle (or expected region) of the screen. If the result is not what you expect, try to root cause and fix (e.g. viewport, NDC, clear vs draw order). If it turns out to be too difficult to fix, raise the issue to the human and we can figure it out together.
    - Run env/bin/cit.py; fix any new lint issues in touched files.
    - Update this file PROGRESS to "Last completed: Task 5.3".
    - After task: commit with message e.g. "chore(agent): mark GenericDraw solid-triangle sample complete".

---
PHASE 6: Implement actual action logic (piece by piece)
---

After the sample app runs (with dummy or minimal logic), implement the real GenericDrawVulkan behavior in small, verifiable steps. Each task should keep the build passing and, where possible, add one concrete piece of the pipeline/draw path.

[ ] Task 6.1 — Create VkShaderModules from CreateParameters (vs/ps)
    - In GenericDrawVulkan, from CreateParameters (stored at construction or when create() is called), create VkShaderModule for the vertex shader and fragment shader when shaderBinary (Blob) and entryPoint are present. Use mGpu->device() to create modules. Store the module handles (or a small struct) on the instance; do not create pipeline yet.
    - Handle missing/invalid binary: skip that stage and log; later pipeline creation will only run when both vs and ps modules exist.
    - Verification: Build succeeds. With valid vs+ps Blobs, two VkShaderModules are created; no leak (destroy modules in destructor or when replacing).
    - After task: commit with message e.g. "feat(rdg): create VkShaderModules from GenericDraw CreateParameters".

[ ] Task 6.2 — Create pipeline layout (no descriptors)
    - Create a VkPipelineLayout with no descriptor sets and no push constants (empty layout) for the minimal solid-color triangle. Use the same device. Store layout handle on the instance.
    - Verification: Build succeeds. Pipeline layout is created and destroyed in destructor; no validation errors.
    - After task: commit with message e.g. "feat(rdg): add pipeline layout for GenericDrawVulkan (no descriptors)".

[ ] Task 6.3 — Create graphics pipeline (dynamic rendering, minimal state)
    - Build a VkPipeline (graphics) using the shader modules and pipeline layout. Use dynamic rendering (no VkRenderPass). Set minimal state: vertex input (no bindings for gl_VertexIndex-only draw), input assembly (triangle list), rasterization, multisample (1 sample), color blend (one attachment, opaque), dynamic state for viewport/scissor if needed.
    - Cache the pipeline handle on the instance. Creation can be lazy (first execute) or at end of prepare; ensure it runs only once when vs+ps are valid.
    - Verification: Build succeeds. Pipeline is created when both shader modules exist; pipeline and layout destroyed in destructor.
    - After task: commit with message e.g. "feat(rdg): add graphics pipeline creation for GenericDrawVulkan (dynamic rendering)".

[ ] Task 6.4 — Set viewport and scissor in execute() from render target extent
    - In execute(), before binding the pipeline (or immediately after beginRendering in the render pass path), set viewport and scissor to match the current color target extent (from the RenderTarget used for this task). Use vkCmdSetViewport and vkCmdSetScissor (or equivalent) so the draw is not clipped incorrectly.
    - Verification: Build succeeds. Run sample; triangle fills the expected area (or is correctly clipped). No validation errors about viewport/scissor.
    - After task: commit with message e.g. "feat(rdg): set viewport and scissor from render target in GenericDrawVulkan".

[ ] Task 6.5 — Bind pipeline and issue draw in execute()
    - In execute(), after the render pass has begun and viewport/scissor are set: bind the cached graphics pipeline (vkCmdBindPipeline), then call vkCmdDraw with drawParams (vertexCount, instanceCount, firstVertex, firstInstance) from GenericDraw::A. For the sample (no mesh), these are 3, 1, 0, 0.
    - Ensure the dummy path (null pipeline) still returns PASSED and skips bind/draw so that running without shaders does not crash.
    - Verification: Build succeeds. Run sample; solid-color triangle is visible. No Vulkan validation errors for bind or draw.
    - After task: commit with message e.g. "feat(rdg): bind pipeline and vkCmdDraw in GenericDrawVulkan::execute()".

[ ] Task 6.6 — (Optional) Cleanup and error handling
    - Ensure destructor destroys pipeline, pipeline layout, and shader modules in correct order. If pipeline creation fails mid-way, log and leave pipeline null; execute() continues to use dummy path.
    - Verification: No leaks; sample runs and exits cleanly; running with missing shaders logs and does not crash.
    - After task: commit with message e.g. "fix(rdg): GenericDrawVulkan cleanup and error handling".

---
PHASE 7: (Optional) Robustness and edge cases
---

[ ] Task 7.1 — (Optional) Handle pipeline creation failure
    - If vs or ps is missing or invalid, log and return FAILED from execute (or from a lazy init). Sample should not crash.
    - Verification: Run sample with one shader omitted; no crash; error logged.

[ ] Task 7.2 — (Optional) Add minimal Mesh path
    - If backend currently requires vertex buffers for vkCmdDraw, create a minimal Mesh (or use a tiny vertex buffer) for 3 vertices; sample sets mesh in GenericDraw::A and drawParams accordingly. Otherwise leave mesh optional and use non-indexed draw without vertex buffer (if Vulkan allows with vertexCount=3 and gl_VertexIndex in the shader).
    - Verification: Triangle still renders; no validation errors.

---
Summary of files to touch (for review)
---

- src/core/rdg/vk-draw-actions.cpp — Task 1.1: rename to GenericDrawVulkan; Phase 3: dummy path (3.1), then pipeline cache (3.2), bind+draw (3.3); Phase 6: actual logic piece by piece (shader modules 6.1, pipeline layout 6.2, pipeline 6.3, viewport/scissor 6.4, bind+draw 6.5, cleanup 6.6).
- src/core/rdg/draw-actions.cpp — add GenericDraw::create().
- src/sample/rdg/ — Phase 4: shader sources (.vert, .frag), compile script (compile_shaders.py or .sh), generated SPIR-V headers (.spv.h); CMake to run script and/or include headers. Sample includes headers and uses arrays as Blob for GenericDraw.
- src/sample/rdg/simple-triangle.cpp — update clear API; remove ClearDepthStencil; add GenericDraw::create and GenericDraw task with renderTarget + drawParams + shaders from SPIR-V headers.

No other files required unless we introduce ClearDepthStencil or new public API.
