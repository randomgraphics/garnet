# Assignment: RDG internal code and tests — match new public headers

Goal: Update RDG implementation (src/core/rdg) and RDG tests (src/test/ut/rdg) so they compile, run, and behave correctly with the current public headers. Discovery uses Arguments::firstArtifactArgument() and ArtifactArgument::next() (linked list, zero allocation); workflow dependencies are derived from artifact usage at submit time; Workflow has no dependencies field; schedule() must assign sequence.

Done looks like: Build passes, all RDG unit tests pass, submission builds workflow dependencies from task artifact usage (via firstArtifactArgument()/next()), and no references to removed APIs (e.g. forEachArtifactParameter, workflow->dependencies).

--- PROGRESS (resume from "Last completed" / "In progress") ---
Last completed: Task 1.2 (linked list; stop for review before continuing)
In progress: (none)
--- END PROGRESS ---

Reference:
- Public headers: src/inc/garnet/rdg/dependency-graph.h, actions.h, artifacts.h
- Current API: Arguments::ArgumentReflection (mHead, mTail, enlist links into list); Arguments::firstArtifactArgument() and ArtifactArgument::next()/prev() for iteration (no allocation). ArtifactArgument is the base (no separate Argument type); ArtifactArgument<UFlags> template for SingleArtifact/ArrayArtifact. ReflectionRegister = ArgumentReflection. Workflow: name, sequence, tasks only.
- RDG core: src/core/rdg/ (dependency-graph.cpp, submission.cpp, submission.h, …)
- RDG test: src/test/ut/rdg/rdg-smoke.cpp

Build/CI:
- Build: build.py d (see .cursor/skills/use-build-py/SKILL.md)
- Lint + test: env/bin/cit.py (see .cursor/skills/run-cit/SKILL.md)

Workflow:
- One task at a time; run build (and cit when applicable) after each task; update PROGRESS.
- Only change src/core/rdg, src/test/ut/rdg, and this agent file. Do not change other modules’ headers.
- For each task, add or extend a unit test that verifies the task’s functionality.

---
PHASE 1: Header compatibility and schedule
---

[ ] Task 1.1 — Ensure Arguments reflection compiles and is testable (ArtifactArgument as the only base)
    - No separate base class: use ArtifactArgument as the base. Add in dependency-graph.h (protected section of Arguments): using ReflectionRegister = ArgumentReflection; so that ArtifactArgument(ReflectionRegister & rr, ...) compiles when subclasses pass auto_reflection. Add template<UsageFlag UFlags> struct ArtifactArgument<UFlags> : ArtifactArgument with 2-arg ctor (rr, name) that passes UFlags to the base.
    - Unit test: In rdg-smoke (or a new test case testArgumentsArtifactArgumentsDiscovery), create a minimal Arguments subclass with one WriteOnly<IntegerArtifact> member initialized with (auto_reflection, "output"). Construct it, call firstArtifactArgument(), assert non-null, name() equals "output", usage() includes Writing, and next() is nullptr. Ensures reflection/enlist and firstArtifactArgument() work.
    - Verification: Build passes; new or updated test passes.

[ ] Task 1.2 — ArgumentReflection: linked list with next/prev, no runtime allocation (critical)
    - Replace DynaArray in ArgumentReflection with a doubly linked list: ArtifactArgument gets mutable next/prev pointers; ArgumentReflection holds mHead and mTail only. enlist(arg) links arg into the list (set arg->mPrev = mTail, arg->mNext = nullptr; update mTail->mNext and mTail / mHead). No vector/enlistments, no allocation.
    - Discovery API: replace artifactArguments() with firstArtifactArgument() returning const ArtifactArgument*; add ArtifactArgument::next() and prev() for iteration. Consumers iterate with for (auto* p = args->firstArtifactArgument(); p; p = p->next()) { ... }.
    - Unit test: In rdg-smoke, extend testArgumentsArtifactArgumentsDiscovery (or add testArtifactArgumentLinkedList): for an Arguments with 3 artifact params, iterate firstArtifactArgument() and next() and count nodes; assert count == 3 and order matches enlist order. Ensures zero-allocation list and iteration.
    - Verification: Build passes; new or updated test passes. Stop after this task for review before continuing.

[ ] Task 1.3 — Assign workflow sequence in schedule()
    - In RenderGraphImpl::schedule(), set the new workflow’s sequence to a monotonically increasing value (e.g. member int64_t mNextSequence; newWorkflow->sequence = mNextSequence++).
    - Unit test: In rdg-smoke, add testWorkflowSequenceOrder: create RenderGraph, schedule("w1"), schedule("w2"), schedule("w3"); assert w1->sequence < w2->sequence and w2->sequence < w3->sequence, and all sequences are distinct. Optionally assert sequence values are positive.
    - Verification: Build passes; testWorkflowSequenceOrder passes.

[ ] Task 1.4 — Build dependency graph from artifact usage (remove workflow->dependencies)
    - In submission.cpp, remove all use of workflow->dependencies. In validateAndBuildDependencyGraph(), after validating tasks (non-null action/arguments), build mDependencyGraph from artifact usage: for each workflow and each task, iterate arguments with for (auto* p = arguments->firstArtifactArgument(); p; p = p->next()) and use p->artifacts() and p->usage() to record (artifact*, read/write) for that task. Then add an edge workflow A depends on workflow B (B must run before A) when A.sequence > B.sequence and some task in A uses an artifact that a task in B writes to, or A writes to an artifact that B reads from. Store in mDependencyGraph[workflowIdx] the indices of workflows that must complete before this one.
    - Unit test: Rely on existing testRenderGraphArithmetic: it schedules workflows that have artifact dependencies (init one/two/three, then add, then multiply). After this task, submission must derive dependencies so execution order is correct and result is 9. Add or keep a test that asserts submission->result().executionResult == PASSED and result->value == 9. Optionally add testDependencyGraphFromArtifacts: schedule two workflows where second reads artifact first writes; assert submission runs and completes without error (implicitly verifies dependency was applied).
    - Verification: Build passes; testRenderGraphArithmetic (and any new dependency test) passes.

---
PHASE 2: RDG unit test updates (match new Argument types and API)
---

[ ] Task 2.1 — Fix test argument types and initializers (rdg-smoke.cpp)
    - Use ReadOnly<IntegerArtifact> / WriteOnly<IntegerArtifact> (not ReadOnly<AutoRef<IntegerArtifact>>). SingleArtifact has member AutoRef<T> value. Initialize each artifact parameter with (auto_reflection, "name", usage): e.g. output = { auto_reflection, "output", Arguments::UsageFlag::Writing }, input1 = { auto_reflection, "input1", Arguments::UsageFlag::Reading }. ArtifactArgument ctor is 3-arg (rr, name, usage). If the header only exposes a 2-arg ctor for SingleArtifact (rr, name), then usage comes from UFlags and initializers may be 2-arg; match the header as-is.
    - Unit test: Build and run testRenderGraphArithmetic; assert it passes (correct types and initializers allow execution and firstArtifactArgument()/next() to see parameters).
    - Verification: Build passes; testRenderGraphArithmetic passes.

[ ] Task 2.2 — Ensure test Argument structs are discoverable via firstArtifactArgument()/next()
    - Discovery is firstArtifactArgument() and next(). Registration happens when ArtifactArgument members are constructed with (auto_reflection, "name") or (auto_reflection, "name", usage), which calls enlist(). Ensure InitIntegerAction::A, AddIntegersAction::A, MultiplyIntegersAction::A each have their artifact parameter members correctly initialized so the linked list contains them.
    - Unit test: In rdg-smoke, add testArgumentDiscoveryCounts (or fold into testArgumentsArtifactArgumentsDiscovery): for InitIntegerAction::A(), iterate firstArtifactArgument()/next() and assert count == 1; for AddIntegersAction::A(), count == 3; for MultiplyIntegersAction::A(), count == 3. Ensures enlistment works for test types.
    - Verification: Build passes; new discovery test(s) pass.

[ ] Task 2.3 — Fix test argument assignment and existing scenarios
    - SingleArtifact has AutoRef<T> value. Use .value = artifact or .set(artifact) as per AutoRef API so test code sets inputs/outputs correctly.
    - Unit test: testRenderGraphArithmetic still passes (result 9); testCreateDuplicateTypeNameReturnsNull still passes.
    - Verification: Run rdg-smoke; testRenderGraphArithmetic and testCreateDuplicateTypeNameReturnsNull pass.

---
PHASE 3: Final verification
---

[ ] Task 3.1 — Full build and CI
    - build.py d and env/bin/cit.py. Fix any remaining lint or test failures in rdg or dependent code.
    - Unit test: cit passes (full test suite as the “test” for this task).
    - Verification: Build green; cit passes.

[ ] Task 3.2 — Update this assignment file
    - Mark all tasks done; set Last completed to Task 3.2; add one-line “Done” summary and date at top.

---
Summary of files to touch
---
- src/inc/garnet/rdg/dependency-graph.h   (ReflectionRegister; ArtifactArgument base + template; linked list next/prev, firstArtifactArgument, ArgumentReflection mHead/mTail)
- src/core/rdg/dependency-graph.cpp       (workflow sequence in schedule)
- src/core/rdg/submission.cpp             (build deps from firstArtifactArgument()/next() + usage; remove workflow->dependencies)
- src/core/rdg/submission.h               (only if needed for member/signature changes)
- src/test/ut/rdg/rdg-smoke.cpp           (argument types, initializers, discovery tests, assignment API)
- agent/ASSIGNMENT_RDG_INTERNAL_MATCH_HEADERS.txt (this file; progress updates)
