# -*- coding: GB18030 -*-

import sys, os, os.path, re, fnmatch

################################################################################
#
# Local Utilities
#
################################################################################

# 读取环境变量
def UTIL_getenv( name, defval = '' ):
	if name in os.environ: return os.environ[name]
	else: return defval

# 输出调试信息
def UTIL_trace( level, msg ):
	level = float(level)
	assert( 0 != level )
	if ( CONF_trace > 0 and level <= CONF_trace ) or ( CONF_trace < 0 and level == -CONF_trace ):
		print 'TRACE(%d) : %s'%(level,msg)

# 输出提示信息
def UTIL_info( msg ): print 'INFO : %s'%msg

# 输出警告信息
def UTIL_warn( msg ):
	#print '===================================================================='
	print 'WARNING : %s'%msg
	#print '===================================================================='

# 输出错误信息
def UTIL_error( msg ):
	print '===================================================================='
	print 'ERROR : %s'%msg
	print '===================================================================='

# Fatal Error. Need to halt building
def UTIL_fatal( msg ):
	print '===================================================================='
	print 'FATAL : %s'%msg
	print '===================================================================='
	Exit(-1)

################################################################################
#
# Configurations (part 1/2) : intialize build time constants
#
################################################################################

LOCAL_ENV = Environment( tools=[] )

HOST_OS  = None
HOST_CPU = None
if 'win32' == LOCAL_ENV['PLATFORM']:
	HOST_OS = 'mswin'
	if 'AMD64' == UTIL_getenv('PROCESSOR_ARCHITECTURE') or 'AMD64' == UTIL_getenv('PROCESSOR_ARCHITEW6432'):
		HOST_CPU = 'x64'
	else:
		HOST_CPU = 'x86'
elif 'cygwin' == LOCAL_ENV['PLATFORM']:
	HOST_OS = 'cygwin'
	HOST_CPU = 'x86'
elif 'posix' == LOCAL_ENV['PLATFORM']:
	HOST_OS = 'posix'
	HOST_CPU = 'x86'
else:
	print 'FATAL: Unknown platform:', LOCAL_ENV['PLATFORM']
	Exit(-1)

# try import xenon extension for SCons
BUILD_HAS_XENON_EXTENSION = False
try:
	sys.path.append( "env/scons/xenon" )
	import xenon
	BUILD_HAS_XENON_EXTENSION = True
except ImportError:
	print "no xenon extension for scons found."

BUILD_COMPILER = UTIL_getenv('GN_BUILD_COMPILER', None )
if None == BUILD_COMPILER:
	if BUILD_HAS_XENON_EXTENSION and xenon.exists( LOCAL_ENV ):
		BUILD_COMPILER = 'xenon'
	elif 'mswin' == HOST_OS:
		BUILD_COMPILER = 'vc100'
	else:
		BUILD_COMPILER = 'gcc'

BUILD_VARIANT = UTIL_getenv('GN_BUILD_VARIANT', 'debug')

BUILD_TARGET_OS = UTIL_getenv('GN_BUILD_TARGET_OS', HOST_OS )

BUILD_TARGET_CPU = UTIL_getenv('GN_BUILD_TARGET_CPU', HOST_CPU )

BUILD_ROOT_PATH = 'b2.tmp/' + BUILD_TARGET_OS + '.' + BUILD_TARGET_CPU + '.' + BUILD_COMPILER + '.' + BUILD_VARIANT + "/"

################################################################################
#
# Create default build envrionment
#
################################################################################

def UTIL_new_env( msvcBatchMode ):

	if 'xenon' == BUILD_COMPILER:

		# construct empty environment for xenon platform
		env = Environment(
			tools          = [],
			MSVC_VERSION   = "8.0",
			MSVS8_PLATFORM = 'Xbox 360',
			ENV            = {
			                 	# Required by Xenon C++ compiler version 15.00.8153.
			                 	# Or else the compiler will report error D8037
								'SystemDrive' : UTIL_getenv('SystemDrive'),
								'SystemRoot'  : UTIL_getenv('SystemRoot'),
				}
			)

		# Setup standard XDK header and library path
		xedk = UTIL_getenv('XEDK');
		inc = os.path.join( xedk, "include" ) + ";" + os.path.join( xedk, "include\\sys" );
		lib = os.path.join( xedk, "lib\\xbox" );

		# Import environment variables that are used by C/C++ compiler.
	 	env.PrependENVPath( 'PATH'     , UTIL_getenv('PATH') );
	 	env.PrependENVPath( 'INCLUDE'  , inc );
	 	env.PrependENVPath( 'LIB'      , lib );
	 	env['ENV']['LANG']     = UTIL_getenv('LANG');
	 	env['ENV']['LANGUAGE'] = UTIL_getenv('LANGUAGE');

		# attach xenon build tools to the environment
		xenon.generate( env )

	else:

		# construct build environment for other platforms

		if 'mswin' == HOST_OS:
			tools = ['msvc','mslink','mslib','msvs','masm']
		else:
			tools = ['default']

		# determine msvs platform
		msvs_platform = 'x86'
		if 'icl' == BUILD_COMPILER:
			tools += ['intelc']
			if 'x64' == HOST_CPU :
				icl_abi = 'em64t'
				msvs_platform = 'x64'
		elif 'x64' == HOST_CPU :
			msvs_platform = 'x64'
		elif 'mingw' == BUILD_COMPILER :
			tools = ['mingw']

		# create new environment
		env = Environment(
			tools          = tools,
			MSVS8_PLATFORM = msvs_platform,
			MSVC_BATCH     = msvcBatchMode,
			)

		# Import environment variables that are used by C/C++ compiler.
	 	env.PrependENVPath( 'PATH'     , UTIL_getenv('PATH') );
	 	env.PrependENVPath( 'INCLUDE'  , UTIL_getenv('INCLUDE') );
	 	env.PrependENVPath( 'LIB'      , UTIL_getenv('LIB') );
	 	env['ENV']['LANG']     = UTIL_getenv('LANG');
	 	env['ENV']['LANGUAGE'] = UTIL_getenv('LANGUAGE');

	# cache implicit dependencies
	env.SetOption( 'implicit_cache', int(UTIL_getenv('SCONS_CACHE_IMPLICIT_DEPS', 1)) );

	# setup default decider
	env.Decider( 'MD5-timestamp' );

	# setup signature file
	env.SConsignFile( BUILD_ROOT_PATH + '.sconsign' )

	# setup GCC precompiled header bilder
	if 'g++' == env['CXX']:

		import SCons.Defaults
		import SCons.Tool

		# attach gch builder
		bld = Builder(
			action = '$CXXCOM',
			suffix = '.h.gch',
			source_scanner = SCons.Tool.SourceFileScanner )
		env.Append( BUILDERS={'PCH':bld} )

		# Sets up the PCH dependencies for an object file
		def pch_emitter( target, source, env, parent_emitter ):
			parent_emitter( target, source, env )
			if env.has_key('PCH') and env['PCH']:
				env.Depends(target, env['PCH'])
			return (target, source)
		def static_pch_emitter(target,source,env):
			return pch_emitter(target,source,env,SCons.Defaults.StaticObjectEmitter)
		def shared_pch_emitter(target,source,env):
			return pch_emitter(target,source,env,SCons.Defaults.SharedObjectEmitter)
		for suffix in Split('.c .C .cc .cxx .cpp .c++'):
			env['BUILDERS']['StaticObject'].add_emitter( suffix, static_pch_emitter );
			env['BUILDERS']['SharedObject'].add_emitter( suffix, shared_pch_emitter );

	# Set standard include path
	env.Append(
		CPPPATH = [
			'#src/extern/inc',
			'#' + BUILD_ROOT_PATH + 'priv/inc',
			'#src/priv/inc',
			],
		)

	# Initialize C/C++ compiler options
	def generate_empty_options() : return { 'common':[],'debug':[],'profile':[],'retail':[] }
	cppdefines = generate_empty_options()
	cpppath    = generate_empty_options()
	libpath    = generate_empty_options()
	libs       = generate_empty_options()
	ccflags    = generate_empty_options()
	cxxflags   = generate_empty_options()
	linkflags  = generate_empty_options()

	# Setup standard options
	cpppath['common']     += [	'#src/extern/inc',
								'#' + BUILD_ROOT_PATH + 'priv/inc',
								'#src/priv/inc',
								];
	libpath['common']     += ['src/extern/lib/' + HOST_OS + '.' + HOST_CPU]
	cppdefines['common']  += ['UNICODE', '_UNICODE']
	cppdefines['debug']   += ['GN_ENABLE_DEBUG=1', 'GN_ENABLE_PROFILING=1', '_DEBUG']
	cppdefines['profile'] += ['GN_ENABLE_DEBUG=0', 'GN_ENABLE_PROFILING=1', 'NDEBUG']
	cppdefines['retail']  += ['GN_ENABLE_DEBUG=0', 'GN_ENABLE_PROFILING=0', 'NDEBUG']

	# Target platform specific options
	if 'xenon' == BUILD_TARGET_OS:
		ccflags['common']     += ['/QVMX128']
		cppdefines['profile'] += ['PROFILE']
		linkflags['profile']  += ['/NODEFAULTLIB:xapilib.lib']
		libs['common']        += Split('xboxkrnl xbdm dxerr9')
		libs['debug']         += Split('xapilibd d3d9d d3dx9d xgraphicsd xnetd xaudiod2 xactd3 vcompd libcmtd')
		libs['profile']       += Split('xapilibi d3d9i d3dx9  xgraphics  xnet  xaudio2  xacti3 vcomp  libcmt')
		libs['retail']        += Split('xapilib  d3d9  d3dx9  xgraphics  xnet  xaudio2  xact3  vcomp  libcmt')
	elif 'mswin' == BUILD_TARGET_OS:
		libs['common']        += Split('kernel32 user32 gdi32 shlwapi advapi32 shell32')
	else:
		cpppath['common']     += Split('/usr/X11R6/include /usr/local/include')
		libpath['common']     += Split('/usr/X11R6/lib /usr/local/lib')

	# Compiler specific options
	if 'cl' == env['CC']:
		#
		# To workaround an bug in scons 0.96.1, this variable has to be imported
		# or else, link.exe will report error: cannot open file 'TEMPFILE'
		#
		env['ENV']['USERPROFILE'] = os.environ['USERPROFILE']

		# Enable C++ EH (with SEH exceptions)
		cxxflags['common']  += ['/EHa']

		ccflags['common']   += ['/W4', '/WX', '/Ot', '/Oi', '/Z7', '/Yd'] # favor speed, enable intrinsic functions.
		ccflags['debug']    += ['/MTd', '/GR', '/RTCscu']
		ccflags['profile']  += ['/MT', '/Ox']
		ccflags['retail']   += ['/MT', '/Ox', '/GL']

		linkflags['common']  += ['/MANIFEST', '/NODEFAULTLIB:libcp.lib', '/FIXED:NO'] # this is for vtune and magellan to do instrumentation
		linkflags['profile'] += ['/OPT:REF']
		linkflags['retail']  += ['/OPT:REF']

	elif 'icl' == env['CC']:
		ccflags['common']  += ['/W3','/WX','/Wcheck','/Qpchi-','/Zc:forScope','/Zi','/debug:full']
		ccflags['debug']   += ['/MTd','/GR','/Ge','/traceback']
		ccflags['profile'] += ['/O2','/MT']
		ccflags['retail']  += ['/O2','/MT']

		# Enable C++ EH (no SEH exceptions)
		cxxflags['common'] += ['/EHs']

		cppdefines['debug'] += ['_DEBUG']

		linkflags['common']  += ['/FIXED:NO', '/DEBUGTYPE:CV,FIXUP'] # this is for vtune and magellan to do instrumentation
		linkflags['profile'] += ['/OPT:REF']
		linkflags['retail']  += ['/OPT:REF']

	elif 'gcc' == env['CC']:
		ccflags['common']  += ['-Wall','-Werror', '-finput-charset=GBK', '-fexec-charset=GBK']
		ccflags['debug']   += ['-g']
		ccflags['profile'] += ['-O3']
		ccflags['retail']  += ['-O3']
		if 'mingw' == BUILD_compiler:
			cppdefines['common'] += ['WINVER=0x500']

	else:
		UTIL_fatal( 'unknown compiler: %s'%env['CC'] )

	# apply compiler options based on current build variant
	def apply_options( env, variant ):
		env.Append(
			CPPDEFINES = cppdefines[variant],
			CPPPATH = cpppath[variant],
			LIBPATH = libpath[variant],
			CCFLAGS = ccflags[variant],
			CXXFLAGS = cxxflags[variant],
			LINKFLAGS = linkflags[variant] );
		env.Prepend(
			LIBS    = libs[variant] ); # for gcc link
	apply_options( env, BUILD_VARIANT )
	apply_options( env, 'common' )

	# Done.
	return env

def UTIL_new_config_env():

	# Create config environment with "batch" mode disabled,
	# since batch mode triggers scons 1.2.0.d20091224 config
	# code bug.
	env = UTIL_new_env( msvcBatchMode = None )

	# Do NOT treat warning as error
	ccflags = str(env['CCFLAGS'])
	ccflags = ccflags.replace( '/WX', '' )
	ccflags = ccflags.replace( '/W4', '/W3' )
	ccflags = ccflags.replace( '-Werror', '')
	env.Replace( CCFLAGS = Split( ccflags ) )

	return env;


################################################################################
#
# Configurations (part 2/2): Run SCons configuration script.
#
################################################################################

CONFIG = {}

def CheckConfig():

	# Create configuration object
	env = UTIL_new_config_env()
	confdir = '#' + BUILD_ROOT_PATH + 'config'
	c = env.Configure( conf_dir=confdir, log_file=confdir + '/config.log' )

	# =========
	# Cg shader
	# =========
	CONFIG['cg_libs'] = []
	if False : # CONF_enableCg :
		CONFIG['has_cg']       = c.CheckLibWithHeader( 'cg', ['Cg/cg.h'], 'C', 'cgCreateContext();' )
		CONFIG['has_cg_ogl']   = c.CheckLibWithHeader( 'cgGL', ['Cg/cg.h','Cg/cgGL.h'], 'C', "cgGLRegisterStates(0);" )
		CONFIG['has_cg_d3d9']  = c.CheckLibWithHeader( 'cgD3D9', ['Cg/cg.h','Cg/cgD3D9.h'], 'C', "cgD3D9SetDevice(0);" )
		CONFIG['has_cg_d3d10'] = c.CheckLibWithHeader( 'cgD3D10', ['Cg/cg.h','Cg/cgD3D10.h'], 'C', "cgD3D10SetDevice(0,0);" )
		CONFIG['has_cg_d3d11'] = c.CheckLibWithHeader( 'cgD3D11', ['Cg/cg.h','Cg/cgD3D11.h'], 'C', "cgD3D11SetDevice(0,0);" )
		if CONFIG['has_cg_ogl']   : CONFIG['cg_libs'] += ['cgGL']
		if CONFIG['has_cg_d3d9']  : CONFIG['cg_libs'] += ['cgD3D9']
		if CONFIG['has_cg_d3d10'] : CONFIG['cg_libs'] += ['cgD3D10']
		if CONFIG['has_cg_d3d11'] : CONFIG['cg_libs'] += ['cgD3D11']
		if CONFIG['has_cg']       : CONFIG['cg_libs'] += ['cg']
	else:
		CONFIG['has_cg']       = 0
		CONFIG['has_cg_ogl']   = 0
		CONFIG['has_cg_d3d9']  = 0
		CONFIG['has_cg_d3d10'] = 0
		CONFIG['has_cg_d3d11'] = 0

	# ======
	# OpenGL
	# ======
	if c.CheckLibWithHeader( 'opengl32', ['GL/glew.h'], 'C', 'glVertex3f(0,0,0);' ) and \
		c.CheckLibWithHeader( 'glu32', ['GL/glew.h','GL/glu.h'], 'C', 'gluOrtho2D(0,0,0,0);' ) :
		CONFIG['has_ogl'] = True
		CONFIG['ogl_libs'] = ['opengl32','glu32']
	elif c.CheckLibWithHeader( 'GL', ['GL/glew.h'], 'C', 'glVertex3f(0,0,0);' ) and \
		c.CheckLibWithHeader( 'GLU', ['GL/glew.h','GL/glu.h'], 'C', 'gluOrtho2D(0,0,0,0);' ) :
		CONFIG['has_ogl'] = True
		CONFIG['ogl_libs'] = ['GL','GLU']
	else :
		CONFIG['has_ogl'] = False
		CONFIG['ogl_libs'] = []

	# ====
	# GLUT
	# ====
	if c.CheckLibWithHeader( 'glut', 'GL/glut.h', 'C', 'glutInit(0,0);' ) :
	    CONFIG['has_glut'] = True
	    CONFIG['glut'] = 'glut'
	elif c.CheckLibWithHeader( 'glut32', 'GL/glut.h', 'C', 'glutInit(0,0);' ) :
	    CONFIG['has_glut'] = True
	    CONFIG['glut'] = 'glut32'
	else :
	    CONFIG['has_glut'] = False

	# =================
	# Misc. D3D headers
	# =================
	CONFIG['has_dxerr']   = c.CheckCXXHeader( ['windows.h','dxerr.h'] )
	CONFIG['has_xnamath'] = c.CheckCXXHeader( ['windows.h','xnamath.h'] ) or c.CheckCXXHeader( ['xtl.h','xnamath.h'] )

	# ====
	# D3D9
	# ====
	CONFIG['has_d3d9'] = ('xenon' == BUILD_TARGET_OS) or ( CONFIG['has_dxerr'] and c.CheckCXXHeader( 'd3d9.h' ) and c.CheckCXXHeader( 'd3dx9.h' ) )

	# =====
	# D3D11
	# =====

	# Detect Windows Vista and Windows 7
	def isVistaOrWin7( env ):
		if 'win32' != env['PLATFORM']: return False
		stdout = os.popen( "ver" )
		str = stdout.read()
		stdout.close()
		import string
		vista = string.find( str, "6.0" ) >= 0
		win7  = string.find( str, "6.1" ) >= 0
		return  vista or win7

	CONFIG['has_d3d11'] = CONFIG['has_dxerr'] and CONFIG['has_d3d9'] and c.CheckLibWithHeader( 'd3d11.lib', 'd3d11.h', 'C++' ) and isVistaOrWin7(env);

	# ===========
	# DirectInput
	# ===========
	CONFIG['has_dinput'] = c.CheckCHeader( ['windows.h', 'dxerr.h', 'dinput.h'] )

	# ======
	# XInput
	# ======
	CONFIG['has_xinput'] = c.CheckCHeader( ['windows.h', 'xinput.h'] ) or c.CheckCHeader( ['xtl.h', 'xinput.h'] )
	CONFIG['has_xinput2'] = c.CheckCHeader( ['windows.h', 'xinput2.h'] ) or c.CheckCHeader( ['xtl.h', 'xinput2.h'] )

	# =====
	# cegui
	# =====
	CONFIG['has_cegui'] = c.CheckCXXHeader( 'CEGUI.h' )

	# ======
	# maxsdk
	# ======
	CONFIG['has_maxsdk'] = c.CheckCHeader( ['max.h','maxapi.h','maxversion.h'] )

	# =====
	# ICONV
	# =====
	if c.CheckLibWithHeader( 'iconv', 'iconv.h', 'c', 'iconv_open(0,0);' ):
	    CONFIG['has_iconv'] = True
	    CONFIG['iconv_lib'] = 'iconv'
	elif c.CheckLibWithHeader( 'libiconv', 'iconv.h', 'c', 'iconv_open(0,0);' ):
	    CONFIG['has_iconv'] = True
	    CONFIG['iconv_lib'] = 'libiconv'
	elif c.CheckLibWithHeader( 'c', 'iconv.h', 'c', 'iconv_open(0,0);' ):
	    CONFIG['has_iconv'] = True
	    CONFIG['iconv_lib'] = 'c'
	else :
		CONFIG['has_iconv'] = False
		CONFIG['iconv_lib'] = []

	# ===
	# FBX
	# ===

	CONFIG['has_fbx'] = False

	FBX_libname = "fbxsdk";
	if BUILD_COMPILER == 'vc100'  : FBX_libname += "_mt2010"
	elif BUILD_COMPILER == 'vc90' : FBX_libname += "_mt2008"
	elif BUILD_COMPILER == 'icl'  : FBX_libname += "_mt2010"
	elif BUILD_COMPILER == 'gcc'  : FBX_libname += "_gcc4"
	if HOST_CPU == 'x64'          : FBX_libname += "_amd64"
	if BUILD_VARIANT == 'debug'   : FBX_libname += 'd'

	FBX_deps = []
	if HOST_OS == 'mswin' : FBX_deps += ['wininet'];

	env.Append( LIBS = FBX_deps )
	if c.CheckLibWithHeader( FBX_libname, ['fbxsdk.h','fbxfilesdk/fbxfilesdk_nsuse.h'], 'C++', 'KFbxSdkManager::Create();' ):
		CONFIG['has_fbx']  = True
		CONFIG['fbx_libs'] = [FBX_libname] + FBX_deps
	for d in FBX_deps: env['LIBS'].remove( d )

	# =============
	# finish config
	# =============
	c.Finish()

CheckConfig()

################################################################################
#
# 定义 GarnetEnv class
#
################################################################################

class GarnetEnv2 :

	def __init__( self ) :

		#
		# Build configurations
		#
		self.target_os    = BUILD_TARGET_OS
		self.target_cpu   = BUILD_TARGET_CPU
		self.cc           = BUILD_COMPILER
		self.variant      = BUILD_VARIANT
		self.host_os      = HOST_OS
		self.static_build = True # TODO: run platform detector
		self.has_cg       = CONFIG['has_cg']
		self.has_cg_ogl   = CONFIG['has_cg_ogl']
		self.has_cg_d3d9  = CONFIG['has_cg_d3d9']
		self.has_cg_d3d10 = CONFIG['has_cg_d3d10']
		self.has_cg_d3d11 = CONFIG['has_cg_d3d11']
		self.has_d3d9     = CONFIG['has_d3d9']
		self.has_d3d10    = False # D3D10 support has been dropped.
		self.has_d3d11    = CONFIG['has_d3d11']
		self.has_dinput   = CONFIG['has_dinput']
		self.has_dxerr    = CONFIG['has_dxerr']
		self.has_fbx      = CONFIG['has_fbx']
		self.has_iconv    = CONFIG['has_iconv']
		self.has_ogl      = CONFIG['has_ogl']
		self.has_xinput   = CONFIG['has_xinput']
		self.has_xinput2  = CONFIG['has_xinput2']
		self.has_xnamath  = CONFIG['has_xnamath']
		self.has_xtl      = 'xenon' == BUILD_TARGET_OS

		#
		# List of known targets that are created by NewTarget method
		#
		self.targets = {}

	#
	# Logging
	#
	def Trace( self, level, msg ): UTIL_trace( level, msg )
	def Info( self, msg ): UTIL_info( msg )
	def Warn( self, msg ): UTIL_warn( msg )
	def Error( self, msg ): UTIL_error( msg )

	#
	# 生成从target到base的相对路径
	#
	def RelativePath( self, target, base ):
		"""
		Return a relative path to the target from either the current dir or an optional base dir.
		Base can be a directory specified either as absolute or relative to current dir.
		"""

		base_list = (os.path.abspath(base)).split(os.sep)
		target_list = (os.path.abspath(target)).split(os.sep)

		# On the windows platform the target may be on a completely different drive from the base.
		if os.name in ['nt','dos','os2'] and base_list[0] <> target_list[0]:
			raise OSError, 'Target is on a different drive to base. Target: '+target_list[0].upper()+', base: '+base_list[0].upper()

		# Starting from the filepath root, work out how much of the filepath is
		# shared by base and target.
		for i in range(min(len(base_list), len(target_list))):
			if base_list[i] <> target_list[i]: break
		else:
			# If we broke out of the loop, i is pointing to the first differing path elements.
			# If we didn't break out of the loop, i is pointing to identical path elements.
			# Increment i so that in all cases it points to the first differing path elements.
			i+=1

		rel_list = [os.pardir] * (len(base_list)-i) + target_list[i:]
		return os.path.join(*rel_list)

	#
	# 查找指定目录下的文件
	#
	def Glob( self, patterns, recursive = False ):
		def do_glob( pattern, dir, recursive ):
			files = []
			root = Dir(dir).srcnode().abspath;
			try:
				for file in os.listdir( root ):
					if os.path.isdir( os.path.join(root,file) ):
						if recursive and ( not '.svn' == file ) : # ignore subversion directory
							files = files + do_glob( pattern, os.path.join(dir,file), recursive )
					else:
						# Note: ignore precompiled headers and makefiles
						if not ('pch.cpp' == file or 'stdafx.cpp' == file or 'makefile.scons' == file):
							#print 'fnmatch(%s,%s) = %s'%(file,pattern,fnmatch.fnmatch(file, pattern))
							if fnmatch.fnmatch(file, pattern):
								files.append( os.path.join( dir, file ) )
			except WindowsError:
				pass
			return files
		#print 'glob %s'%patterns )
		files = []
		if not patterns is list: patterns = [patterns]
		for p in Flatten(patterns):
			if os.path.isdir( GetBuildPath(p) ):
				#print '    do_glob(*.*,%s)'%p
				files += do_glob( '*.*', p, recursive )
			else:
				(dir,pattern) = os.path.split(p);
				if '' == pattern: pattern = '*.*';
				if '' == dir: dir = '.';
				#print '    do_glob(%s,%s)'%(pattern,dir)
				files += do_glob( pattern, dir, recursive )
		return files

	#
	# Remove items from environment list
	#
	def RemoveEnvListItems( self, env, name, toBeRemoved ):
		if toBeRemoved:
			for x in toBeRemoved:
				if x in env[name]:
					env[name].remove(x)

	#
	# Create new configuration environment
	#
	def NewConfigEnv( self ) :
		return UTIL_new_config_env()

	#
	# Create new build environment
	#
	def NewBuildEnv( self ) :

		# create default environment
		env = UTIL_new_env( msvcBatchMode = True )

		return env

	#
	# setup environment for build precompiled header, return PCH object file
	#
	def _BuildSetupPCH( self, env, pchHeader, pchSource ):
		if 'PCH' in env['BUILDERS'] and pchSource:
			pch = env.PCH(pchSource)
			env['PCH'] = pch[0]
			env['PCHSTOP'] = pchHeader
			if( len(pch) > 1 ):
				return [pch[1]]
			else:
				return []
		else:
			return []

	#
	# Setup build environment to build PDB file.
	#
	def _BuildSetupPDB( self, env, target, pdb ):
		if pdb : pdbfile = File(pdb)
		else   : pdbfile = File("%s.pdb"%(target))
		env['PDB'] = pdbfile

	#
	# Setup libraries. Note that this is a private methods that should only
	# be used inside GarnetEnv class.
	#
	def _BuildSetupLibs( self, env ):

		# Add external libraries as needed. Note that
		# when using gcc, the library order matters.
		libs = self.CollectTargets( ['GNcore'] )
		libs += CONFIG['cg_libs']
		libs += CONFIG['ogl_libs']
		libs += CONFIG['fbx_libs']
		libs += CONFIG['iconv_lib']
		dbg = ( BUILD_VARIANT == "debug" )
		if CONFIG['has_d3d9'] and ('xenon' != BUILD_TARGET_OS) :
			libs += ['d3d9.lib', 'd3dx9d.lib'] if dbg else ['d3d9.lib', 'd3dx9.lib']
		if CONFIG['has_d3d11']:
			libs += ['dxgi.lib', 'dxguid.lib', 'dxerr.lib']
			libs += ['d3d11.lib', 'd3dx11d.lib'] if dbg else ['d3d11.lib', 'd3dx11.lib']
		env.Prepend( LIBS = libs )

	#
	# Build list of static object files from list of sources
	#
	def BuildObjects( self, env, sources, pchHeader=None, pchSource=None ):
		if not env: env = self.NewBuildEnv()
		pchobj = self._BuildSetupPCH( env, pchHeader, pchSource )
		return Flatten( [env.Object(x) for x in sources] ) + pchobj

	#
	# Build static library from list of objects
	#
	def BuildLib( self, env, target, objects, pdb=None ):
		if not env: env = self.NewBuildEnv()
		self._BuildSetupPDB( env, target, pdb )
		return env.Library( target, objects )

	#
	# Build executable
	#
	def BuildProgram( self, env, target, sources, pchHeader=None, pchSource=None, pdb=None ):

		# build the program
		if not env: env = self.NewBuildEnv()
		objects = self.BuildObjects( env, sources, pchHeader, pchSource )
		self._BuildSetupPDB( env, target, pdb )
		self._BuildSetupLibs( env )

		return env.Program( target, objects )

	#
	# Copy a set of files to build output folder.
	#
	# To preserve tree structure in sources, all pathes in sources must be relative path.
	#
	def CopyToBinFolder( self, subfolder, sources, preserveDirectoryTree ):
		if '' == subfolder : subfolder = '.'
		targets = []
		for x in sources:
			dst = '#' + BUILD_ROOT_PATH + subfolder + '/'
			if preserveDirectoryTree:
				dst += x
			else:
				dst += os.path.basename( x )
			targets.append( Command( dst, x, Copy( "$TARGET", "$SOURCE" ) ) )
		return Flatten(targets)

	#
	# Binplace program target to bin folder.
	#
	def BinplaceProgram( self, program ):

		# copy to bin folder
		tmp = []
		for x in program:
			dst = '#' + BUILD_ROOT_PATH + 'bin/' + os.path.basename( x.path )
			tmp.append( Command( dst, x, Copy( "$TARGET", "$SOURCE" ) ) )
		Flatten(tmp)
		program = tmp;

		# setup dependency to other targets
		Depends( program, GN.CollectTargets([
			'GNexternBin',
			'GNmedia',
		]))

		# Make program depend on its by-products, such as manifest and PDB,
		# to make sure those files are always up to date.
		for x in program[1:] :
			Depends( program[0], x )

		return program

	#
	# Copy one file to Xenon devkit
	#
	def CopyToDevkit( self, target, source ):
		xedk=UTIL_getenv("XEDK")
		xbcp='%s\\bin\\win32\\xbcp.exe'%(xedk)
		# Note: xbcp.exe requires environment variable "SystemRoot".
		cmdline = 'set SystemRoot=%s&"%s" /Q /D /Y /T "%s" %s'%(
			UTIL_getenv("SystemRoot"),
			xbcp,
			source,
			target)
		Execute( cmdline )

	#
	# Create alias for a build target. So that it can be
	# referenced easily in makefiles.
	#
	def NewTarget( self, name, target ):

		# See if the alias has existed already.
		if self.FindTarget(name, warnForNonExistTarget = False):
			self.Error( 'Alias %s has existed.'%(name) )
			return

		# Create scons alias.
		Alias( name, target )

		# Add to target list
		self.targets[name] = target

	#
	# Create alias for a build target. Also add it into default target list.
	#
	def NewDefaultTarget( self, name, target ):
		self.NewTarget( name, target )
		Default( target )

	#
	# Find one target by name.
	#
	def FindTarget( self, name, warnForNonExistTarget = True ):
		if name in self.targets:
			return self.targets[name]
		else:
			if warnForNonExistTarget: self.Warn( 'Target %s does not exist.'%(name) )
			return None

	#
	# Generate target list from names
	#
	def CollectTargets( self, names, warnForNonExistTarget = True ):
		targets = []
		for name in names:
			t = self.FindTarget( name, warnForNonExistTarget )
			if t: targets += [t]
		return targets

# Create garnet build environment (singleton)
GN = GarnetEnv2()

################################################################################
#
# Build subfolders
#
################################################################################
Export( 'GN' )
SConscript( 'src/makefile.scons', variant_dir=BUILD_ROOT_PATH, duplicate=1)
